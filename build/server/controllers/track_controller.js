// Generated by CoffeeScript 1.9.3
var PlaylistModel, TrackModel, multiparty, os, path, request;

TrackModel = require('../models/track_model');

PlaylistModel = require('../models/playlists_model');

multiparty = require('multiparty');

os = require('os');

path = require('path');

request = require('request-json');

module.exports.all = function(req, res, next) {
  console.log("Get all Tracks");
  return TrackModel.request('all', function(err, data) {
    if (err) {
      return res.status(500).send({
        error: "An error has occured -- " + err
      });
    } else {
      return res.status(200).send(data);
    }
  });
};

module.exports.create = function(req, res, next) {
  var cid, cleanup, files, form, isAllowed, lastPercent;
  cid = null;
  lastPercent = 0;
  files = {};
  isAllowed = !req["public"];
  cleanup = function() {
    return async.each(req.files, function(file, cb) {
      return fs.unlink(file.path, function(err) {
        if (err) {
          console.log('Could not delete %s', file.path);
        }
        return cb(null);
      });
    }, function() {});
  };
  form = new multiparty.Form({
    uploadDir: '/tmp',
    defer: true,
    keepExtensions: true,
    maxFieldsSize: 100 * 1024 * 1024
  });
  form.on('progress', function(bytesReceived, bytesExpected) {
    var percent;
    if (cid == null) {
      return;
    }
    percent = bytesReceived / bytesExpected;
    if (!(percent - lastPercent > 0.05)) {
      return;
    }
    return lastPercent = percent;
  });
  form.on('error', function(err) {
    if (err) {
      return next(err);
    }
  });
  return form.parse(req, function(err, fields, files) {
    var file, track;
    file = files.file[0];
    track = new TrackModel({
      title: fields.title[0],
      artist: fields.artist[0],
      album: fields.album,
      size: file.size,
      track: fields.track,
      year: fields.year,
      genre: fields.genre,
      dateAdded: Date(),
      lastPlay: void 0,
      plays: 0
    });
    return TrackModel.create(track, function(err, newTrack) {
      var data;
      if (err) {
        return next(err);
      }
      data = {
        name: 'source'
      };
      return newTrack.attachBinary(files.file[0].path, data, function(err) {
        if (err) {
          return console.log(err);
        } else {
          console.log("NewTrack : " + newTrack.title);
          return res.status(201).send(newTrack);
        }
      });
    });
  });
};

module.exports.getAttachment = function(req, res, next) {
  return TrackModel.find(req.params.id, function(err, trackFind) {
    var dataUpdate, stream;
    if (trackFind) {
      dataUpdate = {
        lastPlay: Date(),
        plays: trackFind.plays + 1
      };
      trackFind.updateAttributes(dataUpdate, function(err) {
        if (err) {
          return next(err);
        }
      });
      stream = trackFind.getBinary("source", function(err) {
        if (err) {
          return next(err);
        }
      });
      res.on('close', function() {
        return console.log("stop stream");
      });
      return stream.pipe(res);
    }
  });
};

module.exports["delete"] = function(req, res, next) {
  return TrackModel.find(req.params.id, function(err, trackFind) {
    var i, len, playlistId, ref;
    ref = trackFind != null ? trackFind.playlistId : void 0;
    for (i = 0, len = ref.length; i < len; i++) {
      playlistId = ref[i];
      PlaylistModel.find(playlistId, function(err, playlist) {
        var id, index, j, len1, ref1, results;
        if (err) {
          return next(err);
        }
        ref1 = playlist != null ? playlist.trackId : void 0;
        results = [];
        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
          id = ref1[index];
          if (id === trackFind.id) {
            playlist.trackId.splice(index, index + 1);
            playlist.size = playlist.size - 1;
            results.push(playlist.updateAttributes(playlist, function(err) {
              if (err) {
                return next(er);
              }
            }));
          } else {
            results.push(void 0);
          }
        }
        return results;
      });
    }
    trackFind.destroy(function(err) {
      if (err) {
        return next(err);
      }
    });
    return res.status(200).send({
      success: 'Track successfully deleted'
    });
  });
};

module.exports.update = function(req, res, next) {
  delete req.body.state;
  delete req.body.elem;
  return TrackModel.find(req.params.id, function(err, trackFind) {
    if (err) {
      return next(err);
    }
    req.body.lastModified = Date.now();
    return trackFind.updateAttributes(req.body, function(err) {
      if (err) {
        return next(err);
      }
      return res.status(200).send({
        success: 'Track successfully updated'
      });
    });
  });
};

module.exports.youtube = function(req, res, next) {
  var client, url;
  url = "http://youtube.com/watch?v=" + req.params.url;
  client = request.newClient('http://www.youtubeinmp3.com/');
  path = "/fetch/?api=advanced&format=JSON&video=" + (encodeURI(url));
  return client.get(path, function(err, result, videoInfo) {
    var stream;
    req.body.title = videoInfo.title;
    path = "/fetch/?video=" + (encodeURI(url));
    console.log(path);
    stream = client.saveFileAsStream(path, function(err, result, body) {
      if (err) {
        return err;
      }
    });
    return TrackModel.create(req.body, function(err, newTrack) {
      if (err) {
        return next(err);
      }
      return newTrack.attachBinary(stream, {
        name: 'source'
      }, function(err) {
        if (err) {
          return next(err);
        }
        return res.status(200).send(newTrack);
      });
    });
  });
};
